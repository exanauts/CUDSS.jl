<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · CUDSS.jl</title><meta name="title" content="Functions · CUDSS.jl"/><meta property="og:title" content="Functions · CUDSS.jl"/><meta property="twitter:title" content="Functions · CUDSS.jl"/><meta name="description" content="Documentation for CUDSS.jl."/><meta property="og:description" content="Documentation for CUDSS.jl."/><meta property="twitter:description" content="Documentation for CUDSS.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CUDSS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../types/">Types</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#cudss"><span>cudss</span></a></li><li><a class="tocitem" href="#cudss_update"><span>cudss_update</span></a></li><li><a class="tocitem" href="#cudss_set"><span>cudss_set</span></a></li><li><a class="tocitem" href="#cudss_get"><span>cudss_get</span></a></li></ul></li><li><a class="tocitem" href="../generic/">Generic interface</a></li><li><a class="tocitem" href="../schur_complement/">Schur complement</a></li><li><a class="tocitem" href="../uniform_batch/">Uniform batch</a></li><li><a class="tocitem" href="../nonuniform_batch/">Non-uniform batch</a></li><li><a class="tocitem" href="../options/">Options</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/exanauts/CUDSS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/exanauts/CUDSS.jl/blob/main/docs/src/functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h4 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h4><h2 id="cudss"><a class="docs-heading-anchor" href="#cudss">cudss</a><a id="cudss-1"></a><a class="docs-heading-anchor-permalink" href="#cudss" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="CUDSS.cudss"><a class="docstring-binding" href="#CUDSS.cudss"><code>CUDSS.cudss</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cudss(phase::String, solver::CudssSolver{T}, x::CuVector{T}, b::CuVector{T}; asynchronous::Bool=true)
cudss(phase::String, solver::CudssSolver{T}, X::CuMatrix{T}, B::CuMatrix{T}; asynchronous::Bool=true)
cudss(phase::String, solver::CudssSolver{T}, X::CudssMatrix{T}, B::CudssMatrix{T}; asynchronous::Bool=true)
cudss(phase::String, solver::CudssBatchedSolver{T}, x::Vector{CuVector{T}}, b::Vector{CuVector{T}}; asynchronous::Bool=true)
cudss(phase::String, solver::CudssBatchedSolver{T}, X::Vector{CuMatrix{T}}, B::Vector{CuMatrix{T}}; asynchronous::Bool=true)
cudss(phase::String, solver::CudssBatchedSolver{T}, X::CudssBatchedMatrix{T}, B::CudssBatchedMatrix{T}; asynchronous::Bool=true)</code></pre><p>The parameter type <code>T</code> is restricted to <code>Float32</code>, <code>Float64</code>, <code>ComplexF32</code>, or <code>ComplexF64</code>. The keyword argument <code>asynchronous</code> specifies whether to follow the default asynchronous behavior of cuDSS or to perform an explicit synchronization after the call.</p><p>The available phases are:</p><ul><li><code>&quot;reordering&quot;</code>: Reordering;</li><li><code>&quot;symbolic_factorization&quot;</code>: Symbolic factorization;</li><li><code>&quot;analysis&quot;</code>: Reordering and symbolic factorization combined;</li><li><code>&quot;factorization&quot;</code>: Numerical factorization;</li><li><code>&quot;refactorization&quot;</code>: Numerical re-factorization;</li><li><code>&quot;solve_fwd_perm&quot;</code>: Applying reordering permutation to the right hand side before the forward substitution;</li><li><code>&quot;solve_fwd&quot;</code>: Forward substitution sub-step of the solving phase, including the local permutation due to partial pivoting;</li><li><code>&quot;solve_diag&quot;</code>: Diagonal solve sub-step of the solving phase (only needed for symmetric / hermitian indefinite matrices);</li><li><code>&quot;solve_bwd&quot;</code>: Backward substitution sub-step of the solving phase, including the local permutation due to partial pivoting;</li><li><code>&quot;solve_bwd_perm&quot;</code>: Applying inverse reordering permutation to the intermediate solution after the backward substitution. If matching (and scaling) is enabled, this phase also includes applying the inverse matching permutation and inverse scaling (as the matching permutation and scalings were used to modify the matrix before the factorization);</li><li><code>&quot;solve_refinement&quot;</code>: Iterative refinement;</li><li><code>&quot;solve&quot;</code>: Full solving phase, combining all sub-phases and (optional) iterative refinement.</li></ul><p>When the Schur complement mode is enabled (option <code>&quot;schur_mode&quot;</code> set to <code>1</code>), a specific combination of phases is required. For that reason, we added shorthand phases:</p><ul><li><code>&quot;solve_fwd_schur&quot;</code>: combines the phases <code>&quot;solve_fwd_perm&quot;</code>, <code>&quot;solve_fwd&quot;</code>, and <code>&quot;solve_diag&quot;</code>;</li><li><code>&quot;solve_bwd_schur&quot;</code>: combines the phases <code>&quot;solve_bwd&quot;</code> and <code>&quot;solve_bwd_perm&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/CUDSS.jl/blob/c0e52981f98d285984e272d8d88c73752710e5e9/src/interfaces.jl#L469-L498">source</a></section></details></article><h2 id="cudss_update"><a class="docs-heading-anchor" href="#cudss_update">cudss_update</a><a id="cudss_update-1"></a><a class="docs-heading-anchor-permalink" href="#cudss_update" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="CUDSS.cudss_update"><a class="docstring-binding" href="#CUDSS.cudss_update"><code>CUDSS.cudss_update</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cudss_update(solver::CudssSolver{T,INT}, A::CuSparseMatrixCSR{T,INT})
cudss_update(solver::CudssSolver{T,INT}, rowPtr::CuVector{INT}, colVal::CuVector{INT}, nzVal::CuVector{T})
cudss_update(solver::CudssBatchedSolver{T,INT}, A::Vector{CuSparseMatrixCSR{T,INT}})
cudss_update(matrix::CudssMatrix{T}, b::CuVector{T})
cudss_update(matrix::CudssMatrix{T}, B::CuMatrix{T})
cudss_update(matrix::CudssMatrix{T,INT}, A::CuSparseMatrixCSR{T,INT})
cudss_update(matrix::CudssMatrix{T,INT}, rowPtr::CuVector{INT}, colVal::CuVector{INT}, nzVal::CuVector{T})
cudss_update(matrix::CudssBatchedMatrix{T}, b::Vector{CuVector{T}})
cudss_update(matrix::CudssBatchedMatrix{T}, B::Vector{CuMatrix{T}})
cudss_update(matrix::CudssBatchedMatrix{T,INT}, A::Vector{CuSparseMatrixCSR{T,INT}})</code></pre><p>The parameter type <code>T</code> is restricted to <code>Float32</code>, <code>Float64</code>, <code>ComplexF32</code>, or <code>ComplexF64</code>, while <code>INT</code> is restricted to <code>Int32</code> or <code>Int64</code>.</p><p>Update the contents of a <code>CudssMatrix</code> – <code>CudssBatchedMatrix</code> or <code>CudssSolver</code> – <code>CudssBatchedSolver</code> with new numerical values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/CUDSS.jl/blob/c0e52981f98d285984e272d8d88c73752710e5e9/src/interfaces.jl#L151-L166">source</a></section></details></article><h2 id="cudss_set"><a class="docs-heading-anchor" href="#cudss_set">cudss_set</a><a id="cudss_set-1"></a><a class="docs-heading-anchor-permalink" href="#cudss_set" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="CUDSS.cudss_set"><a class="docstring-binding" href="#CUDSS.cudss_set"><code>CUDSS.cudss_set</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cudss_set(solver::CudssSolver, parameter::String, value)
cudss_set(solver::CudssBatchedSolver, parameter::String, value)</code></pre><p>The available configuration parameters are:</p><ul><li><code>&quot;reordering_alg&quot;</code>: Algorithm for the reordering phase (<code>&quot;default&quot;</code>, <code>&quot;algo1&quot;</code>, <code>&quot;algo2&quot;</code>, <code>&quot;algo3&quot;</code>, <code>&quot;algo4&quot;</code>, or <code>&quot;algo5&quot;</code>);</li><li><code>&quot;factorization_alg&quot;</code>: Algorithm for the factorization phase (<code>&quot;default&quot;</code>, <code>&quot;algo1&quot;</code>, <code>&quot;algo2&quot;</code>, <code>&quot;algo3&quot;</code>, <code>&quot;algo4&quot;</code>, or <code>&quot;algo5&quot;</code>);</li><li><code>&quot;solve_alg&quot;</code>: Algorithm for the solving phase (<code>&quot;default&quot;</code>, <code>&quot;algo1&quot;</code>, <code>&quot;algo2&quot;</code>, <code>&quot;algo3&quot;</code>, <code>&quot;algo4&quot;</code>, or <code>&quot;algo5&quot;</code>);</li><li><code>&quot;use_matching&quot;</code>: A flag to enable (<code>1</code>) or disable (<code>0</code>) the matching;</li><li><code>&quot;matching_alg&quot;</code>: Algorithm for the matching;</li><li><code>&quot;solve_mode&quot;</code>: Potential modificator on the system matrix (transpose or adjoint);</li><li><code>&quot;ir_n_steps&quot;</code>: Number of steps during the iterative refinement;</li><li><code>&quot;ir_tol&quot;</code>: Iterative refinement tolerance;</li><li><code>&quot;pivot_type&quot;</code>: Type of pivoting (<code>&#39;C&#39;</code>, <code>&#39;R&#39;</code> or <code>&#39;N&#39;</code>);</li><li><code>&quot;pivot_threshold&quot;</code>: Pivoting threshold which is used to determine if digonal element is subject to pivoting;</li><li><code>&quot;pivot_epsilon&quot;</code>: Pivoting epsilon, absolute value to replace singular diagonal elements;</li><li><code>&quot;max_lu_nnz&quot;</code>: Upper limit on the number of nonzero entries in LU factors for non-symmetric matrices;</li><li><code>&quot;hybrid_memory_mode&quot;</code>: Hybrid memory mode – <code>0</code> (default = device-only) or <code>1</code> (hybrid = host/device);</li><li><code>&quot;hybrid_device_memory_limit&quot;</code>: User-defined device memory limit (number of bytes) for the hybrid memory mode;</li><li><code>&quot;use_cuda_register_memory&quot;</code>: A flag to enable (<code>1</code>) or disable (<code>0</code>) usage of <code>cudaHostRegister()</code> by the hybrid memory mode;</li><li><code>&quot;host_nthreads&quot;</code>: Number of threads to be used by cuDSS in multi-threaded mode;</li><li><code>&quot;hybrid_execute_mode&quot;</code>: Hybrid execute mode – <code>0</code> (default = device-only) or <code>1</code> (hybrid = host/device);</li><li><code>&quot;pivot_epsilon_alg&quot;</code>: Algorithm for the pivot epsilon calculation;</li><li><code>&quot;nd_nlevels&quot;</code>: Minimum number of levels for the nested dissection reordering;</li><li><code>&quot;ubatch_size&quot;</code>: The number of matrices in a uniform batch of systems to be processed by cuDSS;</li><li><code>&quot;ubatch_index&quot;</code>: Use <code>-1</code> (default) to process all matrices in the uniform batch, or a 0-based index to process a single matrix during the factorization or solve phase;</li><li><code>&quot;use_superpanels&quot;</code>: Use superpanel optimization – <code>1</code> (default = enabled) or <code>0</code> (disabled);</li><li><code>&quot;device_count&quot;</code>: Device count in case of multiple device;</li><li><code>&quot;device_indices&quot;</code>: A list of device indices as an integer array;</li><li><code>&quot;schur_mode&quot;</code>: Schur complement mode – <code>0</code> (default = disabled) or <code>1</code> (enabled);</li><li><code>&quot;deterministic_mode&quot;</code>: Enable deterministic mode – <code>0</code> (default = disabled) or <code>1</code> (enabled).</li></ul><p>The available data parameters are:</p><ul><li><code>&quot;info&quot;</code>: Device-side error information;</li><li><code>&quot;user_perm&quot;</code>: User permutation to be used instead of running the reordering algorithms;</li><li><code>&quot;comm&quot;</code>: Communicator for Multi-GPU multi-node mode;</li><li><code>&quot;user_elimination_tree&quot;</code>: User provided elimination tree information, which is used instead of running the reordering algorithm;</li><li><code>&quot;user_schur_indices&quot;</code>: User-provided Schur complement indices. The provided buffer should be an integer array of size <code>n</code>, where <code>n</code> is the dimension of the matrix. The values should be equal to <code>1</code> for the rows / columns which are part of the Schur complement and <code>0</code> for the rest;</li><li><code>&quot;user_host_interrupt&quot;</code>: User-provided host interrupt pointer;</li><li><code>&quot;schur_matrix&quot;</code>: Schur complement matrix passed as a <code>cudssMatrix_t</code> object.</li></ul><p>The data parameter <code>&quot;info&quot;</code> must be restored to <code>0</code> if a Cholesky factorization fails due to indefiniteness and refactorization is performed on an updated matrix.</p><p>Note that for the data parameters <code>&quot;perm_reorder_row&quot;</code>, <code>&quot;perm_row&quot;</code>, <code>&quot;scale_row&quot;</code>, <code>&quot;perm_reorder_col&quot;</code>, <code>&quot;perm_col&quot;</code>, <code>&quot;scale_col&quot;</code>, <code>&quot;perm_matching&quot;</code>, <code>&quot;diag&quot;</code>, and <code>&quot;memory_estimates&quot;</code>, this function only specifies which vector to update for a subsequent call to <a href="#cudss_get"><code>cudss_get</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/CUDSS.jl/blob/c0e52981f98d285984e272d8d88c73752710e5e9/src/interfaces.jl#L222-L268">source</a></section></details></article><h2 id="cudss_get"><a class="docs-heading-anchor" href="#cudss_get">cudss_get</a><a id="cudss_get-1"></a><a class="docs-heading-anchor-permalink" href="#cudss_get" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="CUDSS.cudss_get"><a class="docstring-binding" href="#CUDSS.cudss_get"><code>CUDSS.cudss_get</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">value = cudss_get(solver::CudssSolver, parameter::String)
value = cudss_get(solver::CudssBatchedSolver, parameter::String)</code></pre><p>The available configuration parameters are:</p><ul><li><code>&quot;reordering_alg&quot;</code>: Algorithm for the reordering phase;</li><li><code>&quot;factorization_alg&quot;</code>: Algorithm for the factorization phase;</li><li><code>&quot;solve_alg&quot;</code>: Algorithm for the solving phase;</li><li><code>&quot;use_matching&quot;</code>: A flag to enable (<code>1</code>) or disable (<code>0</code>) the matching;</li><li><code>&quot;matching_alg&quot;</code>: Algorithm for the matching;</li><li><code>&quot;solve_mode&quot;</code>: Potential modificator on the system matrix (transpose or adjoint);</li><li><code>&quot;ir_n_steps&quot;</code>: Number of steps during the iterative refinement;</li><li><code>&quot;ir_tol&quot;</code>: Iterative refinement tolerance;</li><li><code>&quot;pivot_type&quot;</code>: Type of pivoting;</li><li><code>&quot;pivot_threshold&quot;</code>: Pivoting threshold which is used to determine if digonal element is subject to pivoting;</li><li><code>&quot;pivot_epsilon&quot;</code>: Pivoting epsilon, absolute value to replace singular diagonal elements;</li><li><code>&quot;max_lu_nnz&quot;</code>: Upper limit on the number of nonzero entries in LU factors for non-symmetric matrices;</li><li><code>&quot;hybrid_memory_mode&quot;</code>: Hybrid memory mode – <code>0</code> (default = device-only) or <code>1</code> (hybrid = host/device);</li><li><code>&quot;hybrid_device_memory_limit&quot;</code>: User-defined device memory limit (number of bytes) for the hybrid memory mode;</li><li><code>&quot;use_cuda_register_memory&quot;</code>: A flag to enable (<code>1</code>) or disable (<code>0</code>) usage of <code>cudaHostRegister()</code> by the hybrid memory mode;</li><li><code>&quot;host_nthreads&quot;</code>: Number of threads to be used by cuDSS in multi-threaded mode;</li><li><code>&quot;hybrid_execute_mode&quot;</code>: Hybrid execute mode – <code>0</code> (default = device-only) or <code>1</code> (hybrid = host/device);</li><li><code>&quot;pivot_epsilon_alg&quot;</code>: Algorithm for the pivot epsilon calculation;</li><li><code>&quot;nd_nlevels&quot;</code>: Minimum number of levels for the nested dissection reordering;</li><li><code>&quot;ubatch_size&quot;</code>: The number of matrices in a uniform batch of systems to be processed by cuDSS;</li><li><code>&quot;ubatch_index&quot;</code>: Use <code>-1</code> (default) to process all matrices in the uniform batch, or a 0-based index to process a single matrix during the factorization or solve phase;</li><li><code>&quot;use_superpanels&quot;</code>: Use superpanel optimization – <code>1</code> (default = enabled) or <code>0</code> (disabled);</li><li><code>&quot;device_count&quot;</code>: Device count in case of multiple device;</li><li><code>&quot;device_indices&quot;</code>: A list of device indices as an integer array;</li><li><code>&quot;schur_mode&quot;</code>: Schur complement mode – <code>0</code> (default = disabled) or <code>1</code> (enabled);</li><li><code>&quot;deterministic_mode&quot;</code>: Enable deterministic mode – <code>0</code> (default = disabled) or <code>1</code> (enabled).</li></ul><p>The available data parameters are:</p><ul><li><code>&quot;info&quot;</code>: Device-side error information;</li><li><code>&quot;lu_nnz&quot;</code>: Number of non-zero entries in LU factors;</li><li><code>&quot;npivots&quot;</code>: Number of pivots encountered during factorization;</li><li><code>&quot;inertia&quot;</code>: Tuple of positive and negative indices of inertia for symmetric / hermitian indefinite matrices;</li><li><code>&quot;perm_reorder_row&quot;</code>: Reordering permutation for the rows;</li><li><code>&quot;perm_reorder_col&quot;</code>: Reordering permutation for the columns;</li><li><code>&quot;perm_row&quot;</code>: Final row permutation (which includes effects of both reordering and pivoting);</li><li><code>&quot;perm_col&quot;</code>: Final column permutation (which includes effects of both reordering and pivoting);</li><li><code>&quot;perm_matching&quot;</code>: Matching (column) permutation Q such that A[:,Q] is reordered and then factorized;</li><li><code>&quot;scale_row&quot;</code>: A vector of scaling factors applied to the rows of the factorized matrix;</li><li><code>&quot;scale_col&quot;</code>: A vector of scaling factors applied to the columns of the factorized matrix;</li><li><code>&quot;diag&quot;</code>: Diagonal of the factorized matrix;</li><li><code>&quot;hybrid_device_memory_min&quot;</code>: Minimal amount of device memory (number of bytes) required in the hybrid memory mode;</li><li><code>&quot;memory_estimates&quot;</code>: Memory estimates (in bytes) for host and device memory required for the chosen memory mode;</li><li><code>&quot;nsuperpanels&quot;</code>: Number of superpanels in the matrix;</li><li><code>&quot;schur_shape&quot;</code>: Shape of the Schur complement matrix as a triplet (nrows, ncols, nnz);</li><li><code>&quot;schur_matrix&quot;</code>: Retrieve the Schur complement matrix;</li><li><code>&quot;elimination_tree&quot;</code>: User provided elimination tree information, which is used instead of running the reordering algorithm. It must be used in combination with <code>&quot;user_perm&quot;</code> to have an effect.</li></ul><p>The data parameters <code>&quot;info&quot;</code>, <code>&quot;lu_nnz&quot;</code>, <code>&quot;perm_reorder_row&quot;</code>, <code>&quot;perm_reorder_col&quot;</code>, <code>&quot;perm_matching&quot;</code>, <code>&quot;scale_row&quot;</code>, <code>&quot;scale_col&quot;</code>, <code>&quot;hybrid_device_memory_min&quot;</code> and <code>&quot;memory_estimates&quot;</code> require the phase <code>&quot;analyse&quot;</code> performed by <a href="#cudss"><code>cudss</code></a>. The data parameters <code>&quot;npivots&quot;</code>, <code>&quot;inertia&quot;</code> and <code>&quot;diag&quot;</code> require the phases <code>&quot;analyse&quot;</code> and <code>&quot;factorization&quot;</code> performed by <a href="#cudss"><code>cudss</code></a>. The data parameters <code>&quot;perm_matching&quot;</code>, <code>&quot;scale_row&quot;</code>, and <code>&quot;scale_col&quot;</code> require matching to be enabled (the configuration parameter <code>&quot;use_matching&quot;</code> must be set to <code>1</code>).</p><p>Note that for the data parameters <code>&quot;perm_reorder_row&quot;</code>, <code>&quot;perm_row&quot;</code>, <code>&quot;scale_row&quot;</code>, <code>&quot;perm_reorder_col&quot;</code>, <code>&quot;perm_col&quot;</code>, <code>&quot;scale_col&quot;</code>, <code>&quot;perm_matching&quot;</code>, <code>&quot;diag&quot;</code>, and <code>&quot;memory_estimates&quot;</code>, a call to <a href="#cudss_set"><code>cudss_set</code></a> is required beforehand to specify which vector to update.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/CUDSS.jl/blob/c0e52981f98d285984e272d8d88c73752710e5e9/src/interfaces.jl#L337-L395">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Types</a><a class="docs-footer-nextpage" href="../generic/">Generic interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 9 December 2025 23:02">Tuesday 9 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
